/* 
 * Dump QuickLogic ArcticLink III Bx5 Registers
 *
 * Trizeps8Mini V2R1
 */

#include <common.h>
#include <command.h>
#include <dm.h>
#include <i2c.h>

DECLARE_GLOBAL_DATA_PTR;

#define BX5_ADDR 0x64

static int do_bx5_dump(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
#ifdef CONFIG_DM_I2C

	struct udevice *bus, *dev;
	int i2c_bus = 2;
	int ret;
	uint8_t val[4];

	uint8_t CONTROL_BYTE_GEN = 0x09;
	uint8_t bx5_read_cmd[4] = { 0x09, 0x24, 0x05, 0x01 }; // Generic Bx5 Read Command
	uint8_t bx5_register_cmd[38][8] = {
		{ 0x29, 0x05, 0x01, 0x41, 0x04, 0x02, 0x04, 0x00 }, //01 - Read MIPI Client Error Register (0x204)
		{ 0x29, 0x05, 0x01, 0x41, 0x48, 0x01, 0x04, 0x00 }, //02 - Read Device Error Register (0x148)
		{ 0x29, 0x05, 0x01, 0x41, 0x00, 0x07, 0x04, 0x00 }, //03 - (0x700)
		{ 0x29, 0x05, 0x01, 0x41, 0x04, 0x07, 0x04, 0x00 }, //04 - (0x704)
		{ 0x29, 0x05, 0x01, 0x41, 0x0C, 0x07, 0x04, 0x00 }, //05 - (0x70C)
		{ 0x29, 0x05, 0x01, 0x41, 0x10, 0x07, 0x04, 0x00 }, //06 - (0x710)
		{ 0x29, 0x05, 0x01, 0x41, 0x14, 0x07, 0x04, 0x00 }, //07 - (0x714)
		{ 0x29, 0x05, 0x01, 0x41, 0x18, 0x07, 0x04, 0x00 }, //08 - (0x718)
		{ 0x29, 0x05, 0x01, 0x41, 0x1C, 0x07, 0x04, 0x00 }, //09 - (0x71C)
		{ 0x29, 0x05, 0x01, 0x41, 0x20, 0x07, 0x04, 0x00 }, //10 - (0x720)
		{ 0x29, 0x05, 0x01, 0x41, 0x20, 0x01, 0x04, 0x00 }, //11 - (0x120)
		{ 0x29, 0x05, 0x01, 0x41, 0x24, 0x01, 0x04, 0x00 }, //12 - (0x124)
		{ 0x29, 0x05, 0x01, 0x41, 0x28, 0x01, 0x04, 0x00 }, //13 - (0x128)
		{ 0x29, 0x05, 0x01, 0x41, 0x2C, 0x01, 0x04, 0x00 }, //14 - (0x12C)
		{ 0x29, 0x05, 0x01, 0x41, 0x30, 0x01, 0x04, 0x00 }, //15 - (0x130)
		{ 0x29, 0x05, 0x01, 0x41, 0x34, 0x01, 0x04, 0x00 }, //16 - (0x134)
		{ 0x29, 0x05, 0x01, 0x41, 0x38, 0x01, 0x04, 0x00 }, //17 - (0x138)
		{ 0x29, 0x05, 0x01, 0x41, 0x3C, 0x01, 0x04, 0x00 }, //18 - (0x13C)
		{ 0x29, 0x05, 0x01, 0x41, 0x40, 0x01, 0x04, 0x00 }, //19 - (0x140)
		{ 0x29, 0x05, 0x01, 0x41, 0x0C, 0x02, 0x04, 0x00 }, //20 - (0x20C)
		{ 0x29, 0x05, 0x01, 0x41, 0x1C, 0x02, 0x04, 0x00 }, //21 - (0x21C)
		{ 0x29, 0x05, 0x01, 0x41, 0x24, 0x02, 0x04, 0x00 }, //22 - (0x224)
		{ 0x29, 0x05, 0x01, 0x41, 0x28, 0x02, 0x04, 0x00 }, //23 - (0x228)
		{ 0x29, 0x05, 0x01, 0x41, 0x2C, 0x02, 0x04, 0x00 }, //24 - (0x22C)
		{ 0x29, 0x05, 0x01, 0x41, 0x30, 0x02, 0x04, 0x00 }, //25 - (0x230)
		{ 0x29, 0x05, 0x01, 0x41, 0x34, 0x02, 0x04, 0x00 }, //26 - (0x234)
		{ 0x29, 0x05, 0x01, 0x41, 0x38, 0x02, 0x04, 0x00 }, //27 - (0x238)
		{ 0x29, 0x05, 0x01, 0x41, 0x44, 0x02, 0x04, 0x00 }, //28 - (0x244)
		{ 0x29, 0x05, 0x01, 0x41, 0x58, 0x02, 0x04, 0x00 }, //29 - (0x258)
		{ 0x29, 0x05, 0x01, 0x41, 0x7C, 0x03, 0x04, 0x00 }, //30 - (0x37C)
		{ 0x29, 0x05, 0x01, 0x41, 0x80, 0x03, 0x04, 0x00 }, //31 - (0x380)
		{ 0x29, 0x05, 0x01, 0x41, 0x84, 0x03, 0x04, 0x00 }, //32 - (0x384)
		{ 0x29, 0x05, 0x01, 0x41, 0x88, 0x03, 0x04, 0x00 }, //33 - (0x388)
		{ 0x29, 0x05, 0x01, 0x41, 0x8C, 0x03, 0x04, 0x00 }, //34 - (0x38C)
		{ 0x29, 0x05, 0x01, 0x41, 0x94, 0x03, 0x04, 0x00 }, //35 - (0x394)
		{ 0x29, 0x05, 0x01, 0x41, 0x00, 0x06, 0x04, 0x00 }, //36 - (0x600)
		{ 0x29, 0x05, 0x01, 0x41, 0x04, 0x06, 0x04, 0x00 }, //37 - (0x604)
		{ 0x29, 0x05, 0x01, 0x41, 0x08, 0x06, 0x04, 0x00 }, //38 - (0x608)
	};
	struct i2c_msg i2c_msg[2];

	ret = uclass_get_device_by_seq(UCLASS_I2C, i2c_bus, &bus);
	if (ret) {
		printf("%s: No Bus %d\n", __func__, i2c_bus);
		return ret;
	}

	ret = dm_i2c_probe(bus, BX5_ADDR, 0, &dev);
	if (ret) {
		printf("%s: Can not find device id = 0x%x on bus %d\n", 
		        __func__, BX5_ADDR, i2c_bus);
		return ret;
	}


	i2c_msg[0].addr = BX5_ADDR;
	i2c_msg[0].flags = 0;
	i2c_msg[0].len = 4;
	i2c_msg[0].buf = &bx5_read_cmd;

	i2c_msg[1].addr = BX5_ADDR;
	i2c_msg[1].flags = I2C_M_RD;
	i2c_msg[1].len = 4;
	i2c_msg[1].buf = &val;
	

	for(int i=0; i<38; i++)
	{
		ret = dm_i2c_write(dev, CONTROL_BYTE_GEN, bx5_register_cmd[i], sizeof(bx5_register_cmd[i]));
		if(ret) {
			printf("%s: Error writing command: %d\n", __func__, ret);
			return ret;
		}

		ret = dm_i2c_xfer(dev, &i2c_msg[0], 2);
		if(ret) {
			printf("%s: Error reading Error Registers: %d\n", __func__, ret);
			return ret;
		}
		printf("Bx5 Register 0x%02x%02x: 0x%02x%02x %02x%02x\n", bx5_register_cmd[i][5], bx5_register_cmd[i][4], val[3], val[2], val[1], val[0]); 
	}
#else
	printf("error: i2c driver model not active\n");
#endif
	return 0;
}

U_BOOT_CMD(
	bx5_dump, CONFIG_SYS_MAXARGS, 1, do_bx5_dump, 
	"Dump QuickLogic ArcticLink III Bx5 registers",
	"Reads the QuickLogic ArcticLink III Bx5 registers via I2C and prints the response."
);

